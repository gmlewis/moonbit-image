// -*- compile-command: "moon test --target js > got.txt"; -*-

// This file is based on the Go implementation found here:
// https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/image/png/reader_test.go
// which has the copyright notice:
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

typealias Slice[T] = @io.Slice[T]

type! TestError String derive(Show)

// header copied here to enable black-box testing.
const HEADER = b"\x89PNG\r\n\x1a\n"

test "incomplete idat on row boundary" {
  println("\n=== RUN   TestIncompleteIDATOnRowBoundary")
  // The following is an invalid 1x2 grayscale PNG image. The header is OK,
  // but the zlib-compressed IDAT payload contains two bytes "\x02\x00",
  // which is only one row of data (the leading "\x02" is a row filter).
  let ihdr = b"\x00\x00\x00\x0dIHDR\x00\x00\x00\x01\x00\x00\x00\x02\x08\x00\x00\x00\x00\xbc\xea\xe9\xfb"
  let idat = b"\x00\x00\x00\x0eIDAT\x78\x9c\x62\x62\x00\x04\x00\x00\xff\xff\x00\x06\x00\x03\xfa\xd0\x59\xae"
  let iend = b"\x00\x00\x00\x00IEND\xae\x42\x60\x82"
  let data = @io.Buffer::new()
  guard let (_, None) = data.write_bytes(HEADER)
  guard let (_, None) = data.write_bytes(ihdr)
  guard let (_, None) = data.write_bytes(idat)
  guard let (_, None) = data.write_bytes(iend)

  //
  let (_, err) = @png.decode(data)
  if err == None {
    raise TestError("got nil error, want non-nil")
  }
}

test "training idat chunks" {
  println("\n=== RUN   TestTrailingIDATChunks")
  // The following is a valid 1x1 PNG image containing color.Gray{255} and
  // a trailing zero-length IDAT chunk (see PNG specification section 12.9):
  let ihdr = b"\x00\x00\x00\x0dIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x00\x00\x00\x00\x3a\x7e\x9b\x55"
  let idat_white = b"\x00\x00\x00\x0eIDAT\x78\x9c\x62\xfa\x0f\x08\x00\x00\xff\xff\x01\x05\x01\x02\x5a\xdd\x39\xcd"
  let idat_zero = b"\x00\x00\x00\x00IDAT\x35\xaf\x06\x1e"
  let iend = b"\x00\x00\x00\x00IEND\xae\x42\x60\x82"
  let data = @io.Buffer::new()
  guard let (_, None) = data.write_bytes(HEADER)
  guard let (_, None) = data.write_bytes(ihdr)
  guard let (_, None) = data.write_bytes(idat_white)
  guard let (_, None) = data.write_bytes(idat_zero)
  guard let (_, None) = data.write_bytes(iend)

  //
  let (_, err) = @png.decode(data)
  if err != None {
    raise TestError("decoding valid image: \{err}")
  }

  // Non-zero-length trailing IDAT chunks should be ignored (recoverable error).
  // The following chunk contains a single pixel with color.Gray{0}.
  let idat_black = b"\x00\x00\x00\x0eIDAT\x78\x9c\x62\x62\x00\x04\x00\x00\xff\xff\x00\x06\x00\x03\xfa\xd0\x59\xae"
  let data = @io.Buffer::new()
  guard let (_, None) = data.write_bytes(HEADER)
  guard let (_, None) = data.write_bytes(ihdr)
  guard let (_, None) = data.write_bytes(idat_white)
  guard let (_, None) = data.write_bytes(idat_black)
  guard let (_, None) = data.write_bytes(iend)
  let (img, err) = @png.decode(data)
  if err != None {
    raise TestError("trailing IDAT not ignored: \{err}")
  }
  if img.at(0, 0) == @color.Gray::new(0) {
    raise TestError("decoded image from trailing IDAT chunk")
  }
}

// func TestMultipletRNSChunks(t *testing.T) {
test "multiple rns chunks" {
  // The following is a valid 1x1 paletted PNG image with a 1-element palette
  // containing color.NRGBA{0xff, 0x00, 0x00, 0x7f}:
  //   0000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452  .PNG........IHDR
  //   0000010: 0000 0001 0000 0001 0803 0000 0028 cb34  .............(.4
  //   0000020: bb00 0000 0350 4c54 45ff 0000 19e2 0937  .....PLTE......7
  //   0000030: 0000 0001 7452 4e53 7f80 5cb4 cb00 0000  ....tRNS..\.....
  //   0000040: 0e49 4441 5478 9c62 6200 0400 00ff ff00  .IDATx.bb.......
  //   0000050: 0600 03fa d059 ae00 0000 0049 454e 44ae  .....Y.....IEND.
  //   0000060: 4260 82                                  B`.
  // Dropping the tRNS chunk makes that color's alpha 0xff instead of 0x7f.
  let ihdr = b"\x00\x00\x00\x0dIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x03\x00\x00\x00\x28\xcb\x34\xbb"
  let plte = b"\x00\x00\x00\x03PLTE\xff\x00\x00\x19\xe2\x09\x37"
  let trns = b"\x00\x00\x00\x01tRNS\x7f\x80\x5c\xb4\xcb"
  let idat = b"\x00\x00\x00\x0eIDAT\x78\x9c\x62\x62\x00\x04\x00\x00\xff\xff\x00\x06\x00\x03\xfa\xd0\x59\xae"
  let iend = b"\x00\x00\x00\x00IEND\xae\x42\x60\x82"

  //
  for i = 0; i < 4; i = i + 1 {
    let data = @io.Buffer::new()
    guard let (_, None) = data.write_bytes(HEADER)
    guard let (_, None) = data.write_bytes(ihdr)
    guard let (_, None) = data.write_bytes(plte)
    for j = 0; j < i; j = j + 1 {
      guard let (_, None) = data.write_bytes(trns)

    }
    guard let (_, None) = data.write_bytes(idat)
    guard let (_, None) = data.write_bytes(iend)

    //
    let mut want : @color.Color = @color.black
    let (m, err) = @png.decode(data)
    match i {
      0 => {
        if err != None {
          raise TestError("\{i} tRNS chunks: \{err}")
          continue
        }
        want = @color.RGBA::new(0xff, 0x00, 0x00, 0xff)
      }
      1 => {
        if err != None {
          raise TestError("\{i} tRNS chunks: \{err}")
          continue
        }
        want = @color.NRGBA::new(0xff, 0x00, 0x00, 0x7f)
      }
      _ => {
        if err == None {
          raise TestError("\{i} tRNS chunks: got nil error, want non-nil")
        }
        continue
      }
    }
    let got = m.at(0, 0)
    if got != want {
      raise TestError("\{i} tRNS chunks: got \{got}, want \{want}")
    }
  }
}

// func TestUnknownChunkLengthUnderflow(t *testing.T) {
test "unknown chunk length underflow" {
  let data = [
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0x06, 0xf4, 0x7c, 0x55, 0x04, 0x1a, 0xd3, 0x11, 0x9a, 0x73,
    0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0xff,
    0xff, 0x07, 0xf4, 0x7c, 0x55, 0x04, 0x1a, 0xd3,
  ].map(fn(b) { b.to_byte() })
  let b = @io.Buffer::new()
  guard let (_, None) = b.write_bytes(Bytes::from_array(data))
  let (_, err) = @png.decode(b)
  if err == None {
    raise TestError(
      "Didn't fail reading an unknown chunk with length 0xffffffff",
    )
  }
}

// func TestGray8Transparent(t *testing.T) {
test "gray 8 transparent" {
  // These bytes come from https://golang.org/issues/19553
  let data = [
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49,
    0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0b, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x85, 0x2c, 0x88, 0x80, 0x00, 0x00, 0x00, 0x02, 0x74, 0x52,
    0x4e, 0x53, 0x00, 0xff, 0x5b, 0x91, 0x22, 0xb5, 0x00, 0x00, 0x00, 0x02, 0x62,
    0x4b, 0x47, 0x44, 0x00, 0xff, 0x87, 0x8f, 0xcc, 0xbf, 0x00, 0x00, 0x00, 0x09,
    0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0a, 0xf0, 0x00, 0x00, 0x0a, 0xf0, 0x01,
    0x42, 0xac, 0x34, 0x98, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d, 0x45, 0x07,
    0xd5, 0x04, 0x02, 0x12, 0x11, 0x11, 0xf7, 0x65, 0x3d, 0x8b, 0x00, 0x00, 0x00,
    0x4f, 0x49, 0x44, 0x41, 0x54, 0x08, 0xd7, 0x63, 0xf8, 0xff, 0xff, 0xff, 0xb9,
    0xbd, 0x70, 0xf0, 0x8c, 0x01, 0xc8, 0xaf, 0x6e, 0x99, 0x02, 0x05, 0xd9, 0x7b,
    0xc1, 0xfc, 0x6b, 0xff, 0xa1, 0xa0, 0x87, 0x30, 0xff, 0xd9, 0xde, 0xbd, 0xd5,
    0x4b, 0xf7, 0xee, 0xfd, 0x0e, 0xe3, 0xef, 0xcd, 0x06, 0x19, 0x14, 0xf5, 0x1e,
    0xce, 0xef, 0x01, 0x31, 0x92, 0xd7, 0x82, 0x41, 0x31, 0x9c, 0x3f, 0x07, 0x02,
    0xee, 0xa1, 0xaa, 0xff, 0xff, 0x9f, 0xe1, 0xd9, 0x56, 0x30, 0xf8, 0x0e, 0xe5,
    0x03, 0x00, 0xa9, 0x42, 0x84, 0x3d, 0xdf, 0x8f, 0xa6, 0x8f, 0x00, 0x00, 0x00,
    0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
  ].map(fn(b) { b.to_byte() })
  let b = @io.Buffer::new()
  guard let (_, None) = b.write_bytes(Bytes::from_array(data))
  let (m, err) = @png.decode(b)
  if err != None {
    raise TestError("decode: \{err}")
  }
  let hex = "0123456789abcdef"
  let got = StringBuilder::new()
  let bounds = m.bounds()
  for y = bounds.min.y; y < bounds.max.y; y = y + 1 {
    for x = bounds.min.x; x < bounds.max.x; x = x + 1 {
      let (r, _, _, a) = m.at(x, y).rgba()
      if a != 0 {
        got.write_char(' ')
        got.write_char(hex[0x0f & (r >> 12).reinterpret_as_int()])
        got.write_char(hex[0x0f & (r >> 8).reinterpret_as_int()])
      } else {
        got.write_string(" ..")
      }
    }
    got.write_string("\n")
  }

  //
  let want =
    #| .. .. .. ce bd bd bd bd bd bd bd bd bd bd e6
    #| .. .. .. 7b 84 94 94 94 94 94 94 94 94 6b bd
    #| .. .. .. 7b d6 .. .. .. .. .. .. .. .. 8c bd
    #| .. .. .. 7b d6 .. .. .. .. .. .. .. .. 8c bd
    #| .. .. .. 7b d6 .. .. .. .. .. .. .. .. 8c bd
    #| e6 bd bd 7b a5 bd bd f7 .. .. .. .. .. 8c bd
    #| bd 6b 94 94 94 94 5a ef .. .. .. .. .. 8c bd
    #| bd 8c .. .. .. .. 63 ad ad ad ad ad ad 73 bd
    #| bd 8c .. .. .. .. 63 9c 9c 9c 9c 9c 9c 9c de
    #| bd 6b 94 94 94 94 5a ef .. .. .. .. .. .. ..
    #| e6 b5 b5 b5 b5 b5 b5 f7 .. .. .. .. .. .. ..
    #|

  //
  let got = got.to_string()
  if got.to_string() != want {
    println("got:\n\{got}want:\n\{want}")
    raise TestError("mismatch")
  }
}

// func TestDimensionOverflow(t *testing.T) {
//   maxInt32AsInt := int((1 << 31) - 1)
//   have32BitInts := 0 > (1 + maxInt32AsInt)

//   testCases := []struct {
//     src               []byte
//     unsupportedConfig bool
//     width             int
//     height            int
//   }{
//     // These bytes come from https://golang.org/issues/22304
//     //
//     // It encodes a 2147483646 × 2147483646 (i.e. 0x7ffffffe × 0x7ffffffe)
//     // NRGBA image. The (width × height) per se doesn't overflow an int64, but
//     // (width × height × bytesPerPixel) will.
//     {
//       src: []byte{
//         0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
//         0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe, 0x08, 0x06, 0x00, 0x00, 0x00, 0x30, 0x57, 0xb3,
//         0xfd, 0x00, 0x00, 0x00, 0x15, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x62, 0x62, 0x20, 0x12, 0x8c,
//         0x2a, 0xa4, 0xb3, 0x42, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x38, 0x00, 0x15, 0x2d, 0xef,
//         0x5f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
//       },
//       // It's debatable whether DecodeConfig (which does not allocate a
//       // pixel buffer, unlike Decode) should fail in this case. The Go
//       // standard library has made its choice, and the standard library
//       // has compatibility constraints.
//       unsupportedConfig: true,
//       width:             0x7ffffffe,
//       height:            0x7ffffffe,
//     },

//     // The next three cases come from https://golang.org/issues/38435

//     {
//       src: []byte{
//         0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
//         0x00, 0x00, 0xb5, 0x04, 0x00, 0x00, 0xb5, 0x04, 0x08, 0x06, 0x00, 0x00, 0x00, 0xf5, 0x60, 0x2c,
//         0xb8, 0x00, 0x00, 0x00, 0x15, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x62, 0x62, 0x20, 0x12, 0x8c,
//         0x2a, 0xa4, 0xb3, 0x42, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x38, 0x00, 0x15, 0x2d, 0xef,
//         0x5f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
//       },
//       // Here, width * height = 0x7ffea810, just under MaxInt32, but at 4
//       // bytes per pixel, the number of pixels overflows an int32.
//       unsupportedConfig: have32BitInts,
//       width:             0x0000b504,
//       height:            0x0000b504,
//     },

//     {
//       src: []byte{
//         0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
//         0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x30, 0x6e, 0xc5,
//         0x21, 0x00, 0x00, 0x00, 0x15, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x62, 0x62, 0x20, 0x12, 0x8c,
//         0x2a, 0xa4, 0xb3, 0x42, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x38, 0x00, 0x15, 0x2d, 0xef,
//         0x5f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
//       },
//       unsupportedConfig: false,
//       width:             0x04000000,
//       height:            0x00000001,
//     },

//     {
//       src: []byte{
//         0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
//         0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0xaa, 0xd4, 0x7c,
//         0xda, 0x00, 0x00, 0x00, 0x15, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x62, 0x66, 0x20, 0x12, 0x30,
//         0x8d, 0x2a, 0xa4, 0xaf, 0x42, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x14, 0xd2, 0x00, 0x16, 0x00,
//         0x00, 0x00,
//       },
//       unsupportedConfig: false,
//       width:             0x08000000,
//       height:            0x00000001,
//     },
//   }

//   for i, tc := range testCases {
//     cfg, err := DecodeConfig(bytes.NewReader(tc.src))
//     if tc.unsupportedConfig {
//       if err == nil {
//         t.Errorf("i=%d: DecodeConfig: got nil error, want non-nil", i)
//       } else if _, ok := err.(UnsupportedError); !ok {
//         t.Fatalf("Decode: got %v (of type %T), want non-nil error (of type png.UnsupportedError)", err, err)
//       }
//       continue
//     } else if err != nil {
//       t.Errorf("i=%d: DecodeConfig: %v", i, err)
//       continue
//     } else if cfg.Width != tc.width {
//       t.Errorf("i=%d: width: got %d, want %d", i, cfg.Width, tc.width)
//       continue
//     } else if cfg.Height != tc.height {
//       t.Errorf("i=%d: height: got %d, want %d", i, cfg.Height, tc.height)
//       continue
//     }

//     if nPixels := int64(cfg.Width) * int64(cfg.Height); nPixels > 0x7f000000 {
//       // In theory, calling Decode would succeed, given several gigabytes
//       // of memory. In practice, trying to make a []uint8 big enough to
//       // hold all of the pixels can often result in OOM (out of memory).
//       // OOM is unrecoverable; we can't write a test that passes when OOM
//       // happens. Instead we skip the Decode call (and its tests).
//       continue
//     } else if testing.Short() {
//       // Even for smaller image dimensions, calling Decode might allocate
//       // 1 GiB or more of memory. This is usually feasible, and we want
//       // to check that calling Decode doesn't panic if there's enough
//       // memory, but we provide a runtime switch (testing.Short) to skip
//       // these if it would OOM. See also http://golang.org/issue/5050
//       // "decoding... images can cause huge memory allocations".
//       continue
//     }

//     // Even if we don't panic, these aren't valid PNG images.
//     if _, err := Decode(bytes.NewReader(tc.src)); err == nil {
//       t.Errorf("i=%d: Decode: got nil error, want non-nil", i)
//     }
//   }

//   if testing.Short() {
//     t.Skip("skipping tests which allocate large pixel buffers")
//   }
// }

// func TestDecodePalettedWithTransparency(t *testing.T) {
//   // These bytes come from https://go.dev/issue/54325
//   //
//   // Per the PNG spec, a PLTE chunk contains 3 (not 4) bytes per palette
//   // entry: RGB (not RGBA). The alpha value comes from the optional tRNS
//   // chunk. Here, the PLTE chunk (0x50, 0x4c, 0x54, 0x45, etc) has 16 entries
//   // (0x30 = 48 bytes) and the tRNS chunk (0x74, 0x52, 0x4e, 0x53, etc) has 1
//   // entry (0x01 = 1 byte) that sets the first palette entry's alpha to zero.
//   //
//   // Both Decode and DecodeConfig should pick up that the first palette
//   // entry's alpha is zero.
//   src := []byte{
//     0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
//     0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x04, 0x03, 0x00, 0x00, 0x00, 0x81, 0x54, 0x67,
//     0xc7, 0x00, 0x00, 0x00, 0x30, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e,
//     0x00, 0x23, 0x27, 0x7b, 0xb1, 0x2d, 0x0a, 0x49, 0x3f, 0x19, 0x78, 0x5f, 0xcd, 0xe4, 0x69, 0x69,
//     0xe4, 0x71, 0x59, 0x53, 0x80, 0x11, 0x14, 0x8b, 0x00, 0xa9, 0x8d, 0x95, 0xcb, 0x99, 0x2f, 0x6b,
//     0xd7, 0x29, 0x91, 0xd7, 0x7b, 0xba, 0xff, 0xe3, 0xd7, 0x13, 0xc6, 0xd3, 0x58, 0x00, 0x00, 0x00,
//     0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0xfd, 0x49, 0x44,
//     0x41, 0x54, 0x28, 0xcf, 0x63, 0x60, 0x00, 0x83, 0x55, 0x0c, 0x68, 0x60, 0x9d, 0x02, 0x9a, 0x80,
//     0xde, 0x23, 0x74, 0x15, 0xef, 0x50, 0x94, 0x70, 0x2d, 0xd2, 0x7b, 0x87, 0xa2, 0x84, 0xeb, 0xee,
//     0xbb, 0x77, 0x6f, 0x51, 0x94, 0xe8, 0xbd, 0x7d, 0xf7, 0xee, 0x12, 0xb2, 0x80, 0xd2, 0x3d, 0x54,
//     0x01, 0x26, 0x10, 0x1f, 0x59, 0x40, 0x0f, 0xc8, 0xd7, 0x7e, 0x84, 0x70, 0x1c, 0xd7, 0xba, 0xb7,
//     0x4a, 0xda, 0xda, 0x77, 0x11, 0xf6, 0xac, 0x5a, 0xa5, 0xf4, 0xf9, 0xbf, 0xfd, 0x3d, 0x24, 0x6b,
//     0x98, 0x94, 0xf4, 0xff, 0x7f, 0x52, 0x42, 0x16, 0x30, 0x0e, 0xd9, 0xed, 0x6a, 0x8c, 0xec, 0x10,
//     0x65, 0x53, 0x97, 0x60, 0x23, 0x64, 0x1d, 0x8a, 0x2e, 0xc6, 0x2e, 0x42, 0x08, 0x3d, 0x4c, 0xca,
//     0x81, 0xc1, 0x82, 0xa6, 0xa2, 0x46, 0x08, 0x3d, 0x4a, 0xa1, 0x82, 0xc6, 0x82, 0xa1, 0x4a, 0x08,
//     0x3d, 0xfa, 0xa6, 0x81, 0xa1, 0xa2, 0xc1, 0x9f, 0x10, 0x66, 0xd4, 0x2b, 0x87, 0x0a, 0x86, 0x1a,
//     0x7d, 0x57, 0x80, 0x9b, 0x99, 0xaf, 0x62, 0x1a, 0x1a, 0xec, 0xf0, 0x0d, 0x66, 0x2a, 0x7b, 0x5a,
//     0xba, 0xd2, 0x64, 0x63, 0x4b, 0xa6, 0xb2, 0xb4, 0x02, 0xa8, 0x12, 0xb5, 0x24, 0xa5, 0x99, 0x2e,
//     0x33, 0x95, 0xd4, 0x92, 0x10, 0xee, 0xd0, 0x59, 0xb9, 0x6a, 0xd6, 0x21, 0x24, 0xb7, 0x33, 0x9d,
//     0x01, 0x01, 0x64, 0xbf, 0xac, 0x59, 0xb2, 0xca, 0xeb, 0x14, 0x92, 0x80, 0xd6, 0x9a, 0x53, 0x4a,
//     0x6b, 0x4e, 0x2d, 0x42, 0x52, 0xa1, 0x73, 0x28, 0x54, 0xe7, 0x90, 0x6a, 0x00, 0x92, 0x92, 0x45,
//     0xa1, 0x40, 0x84, 0x2c, 0xe0, 0xc4, 0xa0, 0xb2, 0x28, 0x14, 0xc1, 0x67, 0xe9, 0x50, 0x60, 0x60,
//     0xea, 0x70, 0x40, 0x12, 0x00, 0x79, 0x54, 0x09, 0x22, 0x00, 0x00, 0x30, 0xf3, 0x52, 0x87, 0xc6,
//     0xe4, 0xbd, 0x70, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
//   }

//   cfg, err := DecodeConfig(bytes.NewReader(src))
//   if err != nil {
//     t.Fatalf("DecodeConfig: %v", err)
//   } else if _, _, _, alpha := cfg.ColorModel.(color.Palette)[0].RGBA(); alpha != 0 {
//     t.Errorf("DecodeConfig: got %d, want 0", alpha)
//   }

//   img, err := Decode(bytes.NewReader(src))
//   if err != nil {
//     t.Fatalf("Decode: %v", err)
//   } else if _, _, _, alpha := img.ColorModel().(color.Palette)[0].RGBA(); alpha != 0 {
//     t.Errorf("Decode: got %d, want 0", alpha)
//   }
// }
