// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/image"

import(
  "gmlewis/image/color"
  "gmlewis/io"
)

// Values
pub fn add2_non_neg(Int, Int) -> Int

pub fn mul3_non_neg(Int, Int, Int) -> Int

pub fn pt(Int, Int) -> Point

pub fn rect(Int, Int, Int, Int) -> Rectangle

// Errors
type SizeError
pub impl Eq for SizeError
pub impl Show for SizeError

// Types and methods
pub(all) struct Alpha {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn Alpha::alpha_at(Self, Int, Int) -> @color.Alpha
pub fn Alpha::new(Rectangle) -> Self raise SizeError
pub fn Alpha::new_empty() -> Self
pub fn Alpha::op_get(Self, Point) -> &@color.Color
pub fn Alpha::op_set(Self, Point, &@color.Color) -> Unit
pub fn Alpha::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Alpha::set_alpha(Self, Int, Int, @color.Alpha) -> Unit
pub fn Alpha::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for Alpha

pub(all) struct Alpha16 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn Alpha16::alpha16_at(Self, Int, Int) -> @color.Alpha16
pub fn Alpha16::new(Rectangle) -> Self raise SizeError
pub fn Alpha16::new_empty() -> Self
pub fn Alpha16::op_get(Self, Point) -> &@color.Color
pub fn Alpha16::op_set(Self, Point, &@color.Color) -> Unit
pub fn Alpha16::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Alpha16::set_alpha16(Self, Int, Int, @color.Alpha16) -> Unit
pub fn Alpha16::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for Alpha16

pub(all) struct CMYK {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn CMYK::cmyk_at(Self, Int, Int) -> @color.CMYK
pub fn CMYK::new(Rectangle) -> Self raise SizeError
pub fn CMYK::new_empty() -> Self
pub fn CMYK::op_get(Self, Point) -> &@color.Color
pub fn CMYK::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn CMYK::set_cmyk(Self, Int, Int, @color.CMYK) -> Unit
pub fn CMYK::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for CMYK

pub(all) struct Config {
  color_model : &@color.Model
  width : Int
  height : Int
}
pub fn Config::new_empty() -> Self

pub(all) struct Gray {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn Gray::gray_at(Self, Int, Int) -> @color.Gray
pub fn Gray::new(Rectangle) -> Self raise SizeError
pub fn Gray::new_empty() -> Self
pub fn Gray::op_get(Self, Point) -> &@color.Color
pub fn Gray::op_set(Self, Point, &@color.Color) -> Unit
pub fn Gray::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Gray::set_gray(Self, Int, Int, @color.Gray) -> Unit
pub fn Gray::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for Gray

pub(all) struct Gray16 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn Gray16::gray16_at(Self, Int, Int) -> @color.Gray16
pub fn Gray16::new(Rectangle) -> Self raise SizeError
pub fn Gray16::new_empty() -> Self
pub fn Gray16::op_get(Self, Point) -> &@color.Color
pub fn Gray16::op_set(Self, Point, &@color.Color) -> Unit
pub fn Gray16::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Gray16::set_gray16(Self, Int, Int, @color.Gray16) -> Unit
pub fn Gray16::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for Gray16

pub(all) struct NRGBA {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn NRGBA::new(Rectangle) -> Self raise SizeError
pub fn NRGBA::new_empty() -> Self
pub fn NRGBA::nrgba_at(Self, Int, Int) -> @color.NRGBA
pub fn NRGBA::op_get(Self, Point) -> &@color.Color
pub fn NRGBA::op_set(Self, Point, &@color.Color) -> Unit
pub fn NRGBA::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn NRGBA::set_nrgba(Self, Int, Int, @color.NRGBA) -> Unit
pub fn NRGBA::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for NRGBA

pub(all) struct NRGBA64 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn NRGBA64::new(Rectangle) -> Self raise SizeError
pub fn NRGBA64::new_empty() -> Self
pub fn NRGBA64::nrgba64_at(Self, Int, Int) -> @color.NRGBA64
pub fn NRGBA64::op_get(Self, Point) -> &@color.Color
pub fn NRGBA64::op_set(Self, Point, &@color.Color) -> Unit
pub fn NRGBA64::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn NRGBA64::set_nrgba64(Self, Int, Int, @color.NRGBA64) -> Unit
pub fn NRGBA64::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for NRGBA64

pub(all) struct Paletted {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
  mut palette : @color.Palette
}
pub fn Paletted::new(Rectangle, @color.Palette) -> Self raise SizeError
pub fn Paletted::new_empty() -> Self
pub fn Paletted::op_get(Self, Point) -> &@color.Color
pub fn Paletted::op_set(Self, Point, &@color.Color) -> Unit
pub fn Paletted::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Paletted::set_color_index(Self, Int, Int, Byte) -> Unit
pub fn Paletted::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for Paletted

pub(all) struct Point {
  mut x : Int
  mut y : Int
}
pub fn Point::div(Self, Int) -> Self
pub fn Point::is_in(Self, Rectangle) -> Bool
pub fn Point::mod(Self, Rectangle) -> Self
pub fn Point::mul(Self, Int) -> Self
pub fn Point::to_string(Self) -> String
pub impl Add for Point
pub impl Eq for Point
pub impl Show for Point
pub impl Sub for Point

pub(all) struct RGBA {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn RGBA::new(Rectangle) -> Self raise SizeError
pub fn RGBA::new_empty() -> Self
pub fn RGBA::op_get(Self, Point) -> &@color.Color
pub fn RGBA::op_set(Self, Point, &@color.Color) -> Unit
pub fn RGBA::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn RGBA::rgba_at(Self, Int, Int) -> @color.RGBA
pub fn RGBA::set_rgba(Self, Int, Int, @color.RGBA) -> Unit
pub fn RGBA::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for RGBA

pub(all) struct RGBA64 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
pub fn RGBA64::new(Rectangle) -> Self raise SizeError
pub fn RGBA64::new_empty() -> Self
pub fn RGBA64::op_get(Self, Point) -> &@color.Color
pub fn RGBA64::op_set(Self, Point, &@color.Color) -> Unit
pub fn RGBA64::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn RGBA64::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
pub impl Image for RGBA64

pub(all) struct Rectangle {
  min : Point
  max : Point
}
pub fn Rectangle::add(Self, Point) -> Self
pub fn Rectangle::canon(Self) -> Self
pub fn Rectangle::copy(Self) -> Self
pub fn Rectangle::dx(Self) -> Int
pub fn Rectangle::dy(Self) -> Int
pub fn Rectangle::empty(Self) -> Bool
pub fn Rectangle::inset(Self, Int) -> Self
pub fn Rectangle::intersect(Self, Self) -> Self
pub fn Rectangle::is_in(Self, Self) -> Bool
pub fn Rectangle::new() -> Self
pub fn Rectangle::overlaps(Self, Self) -> Bool
pub fn Rectangle::rgba64_at(Self, Int, Int) -> @color.RGBA64
pub fn Rectangle::size(Self) -> Point
pub fn Rectangle::sub(Self, Point) -> Self
pub fn Rectangle::to_string(Self) -> String
pub fn Rectangle::union(Self, Self) -> Self
pub impl Image for Rectangle
pub impl Eq for Rectangle
pub impl Show for Rectangle

pub(all) struct YCbCr {
  y : @io.Slice[Byte]
  cb : @io.Slice[Byte]
  cr : @io.Slice[Byte]
  y_stride : Int
  c_stride : Int
  subsampling : YCbCrSubsampling
  rect : Rectangle
}
pub fn YCbCr::new(Rectangle, YCbCrSubsampling) -> Self raise SizeError
pub impl Image for YCbCr

pub(all) enum YCbCrSubsampling {
  YCbCrSubsampling444
  YCbCrSubsampling422
  YCbCrSubsampling420
  YCbCrSubsampling440
  YCbCrSubsampling411
  YCbCrSubsampling410
}
pub impl Eq for YCbCrSubsampling
pub impl Show for YCbCrSubsampling

// Type aliases

// Traits
pub(open) trait Image {
  color_model(Self) -> &@color.Model
  bounds(Self) -> Rectangle
  at(Self, Int, Int) -> &@color.Color
  opaque_(Self) -> Bool
  set(Self, Int, Int, &@color.Color) -> Unit
  sub_image(Self, Rectangle) -> &Image
  as_ycbcr(Self) -> YCbCr?
  raw_data(Self) -> @io.Slice[Byte]
  get_bytes_per_pixel(Self) -> Int
  get_stride(Self) -> Int
  pix_offset(Self, Int, Int) -> Int
  color_index_at(Self, Int, Int) -> Byte
}
pub fn &Image::empty(Self) -> Bool
pub fn &Image::new_empty() -> Self

pub(open) trait RGBA64Image {
  rgba64_at(Self, Int, Int) -> @color.RGBA64
  color_model(Self) -> &@color.Model
  bounds(Self) -> Rectangle
  at(Self, Int, Int) -> &@color.Color
}

