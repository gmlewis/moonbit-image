// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/image"

import(
  "gmlewis/image/color"
  "gmlewis/io"
)

// Values
fn add2_non_neg(Int, Int) -> Int

fn mul3_non_neg(Int, Int, Int) -> Int

fn pt(Int, Int) -> Point

fn rect(Int, Int, Int, Int) -> Rectangle

// Errors
type SizeError
fn SizeError::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn SizeError::op_equal(Self, Self) -> Bool // from trait `Eq`
fn SizeError::output(Self, &Logger) -> Unit // from trait `Show`
fn SizeError::to_string(Self) -> String // from trait `Show`
impl Eq for SizeError
impl Show for SizeError

// Types and methods
pub(all) struct Alpha {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn Alpha::alpha_at(Self, Int, Int) -> @color.Alpha
fn Alpha::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Alpha::bounds(Self) -> Rectangle // from trait `Image`
fn Alpha::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Alpha::color_model(Self) -> &@color.Model // from trait `Image`
fn Alpha::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Alpha::get_stride(Self) -> Int // from trait `Image`
fn Alpha::new(Rectangle) -> Self raise SizeError
fn Alpha::new_empty() -> Self
fn Alpha::op_get(Self, Point) -> &@color.Color
fn Alpha::op_set(Self, Point, &@color.Color) -> Unit
fn Alpha::opaque_(Self) -> Bool // from trait `Image`
fn Alpha::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Alpha::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Alpha::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Alpha::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Alpha::set_alpha(Self, Int, Int, @color.Alpha) -> Unit
fn Alpha::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn Alpha::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for Alpha

pub(all) struct Alpha16 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn Alpha16::alpha16_at(Self, Int, Int) -> @color.Alpha16
fn Alpha16::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Alpha16::bounds(Self) -> Rectangle // from trait `Image`
fn Alpha16::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Alpha16::color_model(Self) -> &@color.Model // from trait `Image`
fn Alpha16::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Alpha16::get_stride(Self) -> Int // from trait `Image`
fn Alpha16::new(Rectangle) -> Self raise SizeError
fn Alpha16::new_empty() -> Self
fn Alpha16::op_get(Self, Point) -> &@color.Color
fn Alpha16::op_set(Self, Point, &@color.Color) -> Unit
fn Alpha16::opaque_(Self) -> Bool // from trait `Image`
fn Alpha16::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Alpha16::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Alpha16::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Alpha16::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Alpha16::set_alpha16(Self, Int, Int, @color.Alpha16) -> Unit
fn Alpha16::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn Alpha16::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for Alpha16

pub(all) struct CMYK {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn CMYK::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn CMYK::bounds(Self) -> Rectangle // from trait `Image`
fn CMYK::cmyk_at(Self, Int, Int) -> @color.CMYK
fn CMYK::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn CMYK::color_model(Self) -> &@color.Model // from trait `Image`
fn CMYK::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn CMYK::get_stride(Self) -> Int // from trait `Image`
fn CMYK::new(Rectangle) -> Self raise SizeError
fn CMYK::new_empty() -> Self
fn CMYK::op_get(Self, Point) -> &@color.Color
fn CMYK::opaque_(Self) -> Bool // from trait `Image`
fn CMYK::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn CMYK::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn CMYK::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn CMYK::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn CMYK::set_cmyk(Self, Int, Int, @color.CMYK) -> Unit
fn CMYK::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn CMYK::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for CMYK

pub(all) struct Config {
  color_model : &@color.Model
  width : Int
  height : Int
}
fn Config::new_empty() -> Self

pub(all) struct Gray {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn Gray::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Gray::bounds(Self) -> Rectangle // from trait `Image`
fn Gray::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Gray::color_model(Self) -> &@color.Model // from trait `Image`
fn Gray::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Gray::get_stride(Self) -> Int // from trait `Image`
fn Gray::gray_at(Self, Int, Int) -> @color.Gray
fn Gray::new(Rectangle) -> Self raise SizeError
fn Gray::new_empty() -> Self
fn Gray::op_get(Self, Point) -> &@color.Color
fn Gray::op_set(Self, Point, &@color.Color) -> Unit
fn Gray::opaque_(Self) -> Bool // from trait `Image`
fn Gray::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Gray::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Gray::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Gray::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Gray::set_gray(Self, Int, Int, @color.Gray) -> Unit
fn Gray::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn Gray::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for Gray

pub(all) struct Gray16 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn Gray16::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Gray16::bounds(Self) -> Rectangle // from trait `Image`
fn Gray16::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Gray16::color_model(Self) -> &@color.Model // from trait `Image`
fn Gray16::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Gray16::get_stride(Self) -> Int // from trait `Image`
fn Gray16::gray16_at(Self, Int, Int) -> @color.Gray16
fn Gray16::new(Rectangle) -> Self raise SizeError
fn Gray16::new_empty() -> Self
fn Gray16::op_get(Self, Point) -> &@color.Color
fn Gray16::op_set(Self, Point, &@color.Color) -> Unit
fn Gray16::opaque_(Self) -> Bool // from trait `Image`
fn Gray16::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Gray16::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Gray16::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Gray16::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Gray16::set_gray16(Self, Int, Int, @color.Gray16) -> Unit
fn Gray16::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn Gray16::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for Gray16

pub(all) struct NRGBA {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn NRGBA::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn NRGBA::bounds(Self) -> Rectangle // from trait `Image`
fn NRGBA::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn NRGBA::color_model(Self) -> &@color.Model // from trait `Image`
fn NRGBA::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn NRGBA::get_stride(Self) -> Int // from trait `Image`
fn NRGBA::new(Rectangle) -> Self raise SizeError
fn NRGBA::new_empty() -> Self
fn NRGBA::nrgba_at(Self, Int, Int) -> @color.NRGBA
fn NRGBA::op_get(Self, Point) -> &@color.Color
fn NRGBA::op_set(Self, Point, &@color.Color) -> Unit
fn NRGBA::opaque_(Self) -> Bool // from trait `Image`
fn NRGBA::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn NRGBA::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn NRGBA::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn NRGBA::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn NRGBA::set_nrgba(Self, Int, Int, @color.NRGBA) -> Unit
fn NRGBA::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn NRGBA::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for NRGBA

pub(all) struct NRGBA64 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn NRGBA64::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn NRGBA64::bounds(Self) -> Rectangle // from trait `Image`
fn NRGBA64::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn NRGBA64::color_model(Self) -> &@color.Model // from trait `Image`
fn NRGBA64::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn NRGBA64::get_stride(Self) -> Int // from trait `Image`
fn NRGBA64::new(Rectangle) -> Self raise SizeError
fn NRGBA64::new_empty() -> Self
fn NRGBA64::nrgba64_at(Self, Int, Int) -> @color.NRGBA64
fn NRGBA64::op_get(Self, Point) -> &@color.Color
fn NRGBA64::op_set(Self, Point, &@color.Color) -> Unit
fn NRGBA64::opaque_(Self) -> Bool // from trait `Image`
fn NRGBA64::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn NRGBA64::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn NRGBA64::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn NRGBA64::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn NRGBA64::set_nrgba64(Self, Int, Int, @color.NRGBA64) -> Unit
fn NRGBA64::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn NRGBA64::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for NRGBA64

pub(all) struct Paletted {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
  mut palette : @color.Palette
}
fn Paletted::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Paletted::bounds(Self) -> Rectangle // from trait `Image`
fn Paletted::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Paletted::color_model(Self) -> &@color.Model // from trait `Image`
fn Paletted::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Paletted::get_stride(Self) -> Int // from trait `Image`
fn Paletted::new(Rectangle, @color.Palette) -> Self raise SizeError
fn Paletted::new_empty() -> Self
fn Paletted::op_get(Self, Point) -> &@color.Color
fn Paletted::op_set(Self, Point, &@color.Color) -> Unit
fn Paletted::opaque_(Self) -> Bool // from trait `Image`
fn Paletted::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Paletted::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Paletted::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Paletted::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Paletted::set_color_index(Self, Int, Int, Byte) -> Unit
fn Paletted::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn Paletted::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for Paletted

pub(all) struct Point {
  mut x : Int
  mut y : Int
}
fn Point::add(Self, Self) -> Self // from trait `Add`
fn Point::div(Self, Int) -> Self
fn Point::equal(Self, Self) -> Bool // from trait `Eq`
fn Point::is_in(Self, Rectangle) -> Bool
fn Point::mod(Self, Rectangle) -> Self
fn Point::mul(Self, Int) -> Self
#deprecated
fn Point::op_add(Self, Self) -> Self // from trait `Add`
#deprecated
fn Point::op_equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn Point::op_sub(Self, Self) -> Self // from trait `Sub`
fn Point::output(Self, &Logger) -> Unit // from trait `Show`
fn Point::sub(Self, Self) -> Self // from trait `Sub`
fn Point::to_string(Self) -> String
impl Add for Point
impl Eq for Point
impl Show for Point
impl Sub for Point

pub(all) struct RGBA {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn RGBA::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn RGBA::bounds(Self) -> Rectangle // from trait `Image`
fn RGBA::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn RGBA::color_model(Self) -> &@color.Model // from trait `Image`
fn RGBA::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn RGBA::get_stride(Self) -> Int // from trait `Image`
fn RGBA::new(Rectangle) -> Self raise SizeError
fn RGBA::new_empty() -> Self
fn RGBA::op_get(Self, Point) -> &@color.Color
fn RGBA::op_set(Self, Point, &@color.Color) -> Unit
fn RGBA::opaque_(Self) -> Bool // from trait `Image`
fn RGBA::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn RGBA::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn RGBA::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn RGBA::rgba_at(Self, Int, Int) -> @color.RGBA
fn RGBA::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn RGBA::set_rgba(Self, Int, Int, @color.RGBA) -> Unit
fn RGBA::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn RGBA::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for RGBA

pub(all) struct RGBA64 {
  pix : @io.Slice[Byte]
  stride : Int
  rect : Rectangle
}
fn RGBA64::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn RGBA64::bounds(Self) -> Rectangle // from trait `Image`
fn RGBA64::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn RGBA64::color_model(Self) -> &@color.Model // from trait `Image`
fn RGBA64::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn RGBA64::get_stride(Self) -> Int // from trait `Image`
fn RGBA64::new(Rectangle) -> Self raise SizeError
fn RGBA64::new_empty() -> Self
fn RGBA64::op_get(Self, Point) -> &@color.Color
fn RGBA64::op_set(Self, Point, &@color.Color) -> Unit
fn RGBA64::opaque_(Self) -> Bool // from trait `Image`
fn RGBA64::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn RGBA64::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn RGBA64::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn RGBA64::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn RGBA64::set_rgba64(Self, Int, Int, @color.RGBA64) -> Unit
fn RGBA64::sub_image(Self, Rectangle) -> &Image // from trait `Image`
impl Image for RGBA64

pub(all) struct Rectangle {
  min : Point
  max : Point
}
fn Rectangle::add(Self, Point) -> Self
fn Rectangle::at(Self, Int, Int) -> &@color.Color // from trait `Image`
fn Rectangle::bounds(Self) -> Self // from trait `Image`
fn Rectangle::canon(Self) -> Self
fn Rectangle::color_index_at(Self, Int, Int) -> Byte // from trait `Image`
fn Rectangle::color_model(Self) -> &@color.Model // from trait `Image`
fn Rectangle::copy(Self) -> Self
fn Rectangle::dx(Self) -> Int
fn Rectangle::dy(Self) -> Int
fn Rectangle::empty(Self) -> Bool
fn Rectangle::equal(Self, Self) -> Bool // from trait `Eq`
fn Rectangle::get_bytes_per_pixel(Self) -> Int // from trait `Image`
fn Rectangle::get_stride(Self) -> Int // from trait `Image`
fn Rectangle::inset(Self, Int) -> Self
fn Rectangle::intersect(Self, Self) -> Self
fn Rectangle::is_in(Self, Self) -> Bool
fn Rectangle::new() -> Self
#deprecated
fn Rectangle::op_equal(Self, Self) -> Bool // from trait `Eq`
fn Rectangle::opaque_(Self) -> Bool // from trait `Image`
fn Rectangle::output(Self, &Logger) -> Unit // from trait `Show`
fn Rectangle::overlaps(Self, Self) -> Bool
fn Rectangle::pix_offset(Self, Int, Int) -> Int // from trait `Image`
fn Rectangle::raw_data(Self) -> @io.Slice[Byte] // from trait `Image`
fn Rectangle::rgba64_at(Self, Int, Int) -> @color.RGBA64
fn Rectangle::set(Self, Int, Int, &@color.Color) -> Unit // from trait `Image`
fn Rectangle::size(Self) -> Point
fn Rectangle::sub(Self, Point) -> Self
fn Rectangle::sub_image(Self, Self) -> &Image // from trait `Image`
fn Rectangle::to_string(Self) -> String
fn Rectangle::union(Self, Self) -> Self
impl Image for Rectangle
impl Eq for Rectangle
impl Show for Rectangle

// Type aliases

// Traits
pub(open) trait Image {
  color_model(Self) -> &@color.Model
  bounds(Self) -> Rectangle
  at(Self, Int, Int) -> &@color.Color
  opaque_(Self) -> Bool
  set(Self, Int, Int, &@color.Color) -> Unit
  sub_image(Self, Rectangle) -> &Image
  raw_data(Self) -> @io.Slice[Byte]
  get_bytes_per_pixel(Self) -> Int
  get_stride(Self) -> Int
  pix_offset(Self, Int, Int) -> Int
  color_index_at(Self, Int, Int) -> Byte
}
fn &Image::empty(Self) -> Bool
fn &Image::new_empty() -> Self

pub(open) trait RGBA64Image {
  rgba64_at(Self, Int, Int) -> @color.RGBA64
  color_model(Self) -> &@color.Model
  bounds(Self) -> Rectangle
  at(Self, Int, Int) -> &@color.Color
}

